<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\qunit\qunit.js - MSI App - Docs</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="&#x2F;msi-app&#x2F;img&#x2F;metricstream&#x2F;metricstream-logo-black.png" title="MSI App - Docs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/SettingModel.html">SettingModel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib\qunit\qunit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * QUnit v1.6.0 - A JavaScript Unit Testing Framework
 *
 * http:&#x2F;&#x2F;docs.jquery.com&#x2F;QUnit
 *
 * Copyright (c) 2012 John Resig, JÃ¶rn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 *&#x2F;

(function( window ) {

var QUnit,
	config,
	testId = 0,
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	defined = {
	setTimeout: typeof window.setTimeout !== &quot;undefined&quot;,
	sessionStorage: (function() {
		var x = &quot;qunit-test-string&quot;;
		try {
			sessionStorage.setItem( x, x );
			sessionStorage.removeItem( x );
			return true;
		} catch( e ) {
			return false;
		}
	}())
};

function Test( name, testName, expected, async, callback ) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
}

Test.prototype = {
	init: function() {
		var b, li,
        tests = id( &quot;qunit-tests&quot; );

		if ( tests ) {
			b = document.createElement( &quot;strong&quot; );
			b.innerHTML = &quot;Running &quot; + this.name;

			li = document.createElement( &quot;li&quot; );
			li.appendChild( b );
			li.className = &quot;running&quot;;
			li.id = this.id = &quot;qunit-test-output&quot; + testId++;

			tests.appendChild( li );
		}
	},
	setup: function() {
		if ( this.module !== config.previousModule ) {
			if ( config.previousModule ) {
				runLoggingCallbacks( &quot;moduleDone&quot;, QUnit, {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				});
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			runLoggingCallbacks( &quot;moduleStart&quot;, QUnit, {
				name: this.module
			});
		} else if ( config.autorun ) {
			runLoggingCallbacks( &quot;moduleStart&quot;, QUnit, {
				name: this.module
			});
		}

		config.current = this;

		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment );

		runLoggingCallbacks( &quot;testStart&quot;, QUnit, {
			name: this.testName,
			module: this.module
		});

		&#x2F;&#x2F; allow utility functions to access the current test environment
		&#x2F;&#x2F; TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;

		if ( !config.pollution ) {
			saveGlobal();
		}
		if ( config.notrycatch ) {
			this.testEnvironment.setup.call( this.testEnvironment );
			return;
		}
		try {
			this.testEnvironment.setup.call( this.testEnvironment );
		} catch( e ) {
			QUnit.pushFailure( &quot;Setup failed on &quot; + this.testName + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
		}
	},
	run: function() {
		config.current = this;

		var running = id( &quot;qunit-testresult&quot; );

		if ( running ) {
			running.innerHTML = &quot;Running: &lt;br&#x2F;&gt;&quot; + this.name;
		}

		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call( this.testEnvironment );
			return;
		}

		try {
			this.callback.call( this.testEnvironment );
		} catch( e ) {
			QUnit.pushFailure( &quot;Died on test #&quot; + (this.assertions.length + 1) + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
			&#x2F;&#x2F; else next test will carry the responsibility
			saveGlobal();

			&#x2F;&#x2F; Restart the tests if they&#x27;re blocking
			if ( config.blocking ) {
				QUnit.start();
			}
		}
	},
	teardown: function() {
		config.current = this;
		if ( config.notrycatch ) {
			this.testEnvironment.teardown.call( this.testEnvironment );
			return;
		} else {
			try {
				this.testEnvironment.teardown.call( this.testEnvironment );
			} catch( e ) {
				QUnit.pushFailure( &quot;Teardown failed on &quot; + this.testName + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
			}
		}
		checkPollution();
	},
	finish: function() {
		config.current = this;
		if ( this.expected != null &amp;&amp; this.expected != this.assertions.length ) {
			QUnit.pushFailure( &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; + this.assertions.length + &quot; were run&quot;, this.stack );
		} else if ( this.expected == null &amp;&amp; !this.assertions.length ) {
			QUnit.pushFailure( &quot;Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.&quot;, this.stack );
		}

		var assertion, a, b, i, li, ol,
			good = 0,
			bad = 0,
			tests = id( &quot;qunit-tests&quot; );

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			ol = document.createElement( &quot;ol&quot; );

			for ( i = 0; i &lt; this.assertions.length; i++ ) {
				assertion = this.assertions[i];

				li = document.createElement( &quot;li&quot; );
				li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
				li.innerHTML = assertion.message || ( assertion.result ? &quot;okay&quot; : &quot;failed&quot; );
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			&#x2F;&#x2F; store result when possible
			if ( QUnit.config.reorder &amp;&amp; defined.sessionStorage ) {
				if ( bad ) {
					sessionStorage.setItem( &quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName, bad );
				} else {
					sessionStorage.removeItem( &quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName );
				}
			}

			if ( bad === 0 ) {
				ol.style.display = &quot;none&quot;;
			}

			&#x2F;&#x2F; &#x60;b&#x60; initialized at top of scope
			b = document.createElement( &quot;strong&quot; );
			b.innerHTML = this.name + &quot; &lt;b class=&#x27;counts&#x27;&gt;(&lt;b class=&#x27;failed&#x27;&gt;&quot; + bad + &quot;&lt;&#x2F;b&gt;, &lt;b class=&#x27;passed&#x27;&gt;&quot; + good + &quot;&lt;&#x2F;b&gt;, &quot; + this.assertions.length + &quot;)&lt;&#x2F;b&gt;&quot;;

			&#x2F;&#x2F; &#x60;a&#x60; initialized at top of scope
			a = document.createElement( &quot;a&quot; );
			a.innerHTML = &quot;Rerun&quot;;
			a.href = QUnit.url({ filter: getText([b]).replace( &#x2F;\([^)]+\)$&#x2F;, &quot;&quot; ).replace( &#x2F;(^\s*|\s*$)&#x2F;g, &quot;&quot; ) });

			addEvent(b, &quot;click&quot;, function() {
				var next = b.nextSibling.nextSibling,
					display = next.style.display;
				next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
			});

			addEvent(b, &quot;dblclick&quot;, function( e ) {
				var target = e &amp;&amp; e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == &quot;span&quot; || target.nodeName.toLowerCase() == &quot;b&quot; ) {
					target = target.parentNode;
				}
				if ( window.location &amp;&amp; target.nodeName.toLowerCase() === &quot;strong&quot; ) {
					window.location = QUnit.url({
						filter: getText([target]).replace( &#x2F;\([^)]+\)$&#x2F;, &quot;&quot; ).replace( &#x2F;(^\s*|\s*$)&#x2F;g, &quot;&quot; )
					});
				}
			});

			&#x2F;&#x2F; &#x60;li&#x60; initialized at top of scope
			li = id( this.id );
			li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( a );
			li.appendChild( ol );

		} else {
			for ( i = 0; i &lt; this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		runLoggingCallbacks( &quot;testDone&quot;, QUnit, {
			name: this.testName,
			module: this.module,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		});

		QUnit.reset();
	},

	queue: function() {
		var bad,
			test = this;

		synchronize(function() {
			test.init();
		});
		function run() {
			&#x2F;&#x2F; each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}

		&#x2F;&#x2F; &#x60;bad&#x60; initialized at top of scope
		&#x2F;&#x2F; defer when previous test run passed, if storage is available
		bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp;
						+sessionStorage.getItem( &quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName );

		if ( bad ) {
			run();
		} else {
			synchronize( run, true );
		}
	}
};

&#x2F;&#x2F; &#x60;QUnit&#x60; initialized at top of scope
QUnit = {

	&#x2F;&#x2F; call on start of module test to prepend name to all tests
	module: function( name, testEnvironment ) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function( testName, expected, callback ) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		QUnit.test( testName, expected, callback, true );
	},

	test: function( testName, expected, callback, async ) {
		var test,
			name = &quot;&lt;span class=&#x27;test-name&#x27;&gt;&quot; + escapeInnerText( testName ) + &quot;&lt;&#x2F;span&gt;&quot;;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = &quot;&lt;span class=&#x27;module-name&#x27;&gt;&quot; + config.currentModule + &quot;&lt;&#x2F;span&gt;: &quot; + name;
		}

		if ( !validTest(config.currentModule + &quot;: &quot; + testName) ) {
			return;
		}

		test = new Test( name, testName, expected, async, callback );
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.stack = sourceFromStacktrace( 2 );
		test.queue();
	},

	&#x2F;&#x2F; Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#x27;t slip through.
	expect: function( asserts ) {
		config.current.expected = asserts;
	},

	&#x2F;&#x2F; Asserts true.
	&#x2F;&#x2F; @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
	ok: function( result, msg ) {
		if ( !config.current ) {
			throw new Error( &quot;ok() assertion outside test context, was &quot; + sourceFromStacktrace(2) );
		}
		result = !!result;

		var source,
			details = {
				result: result,
				message: msg
			};

		msg = escapeInnerText( msg || (result ? &quot;okay&quot; : &quot;failed&quot; ) );
		msg = &quot;&lt;span class=&#x27;test-message&#x27;&gt;&quot; + msg + &quot;&lt;&#x2F;span&gt;&quot;;

		if ( !result ) {
			source = sourceFromStacktrace( 2 );
			if ( source ) {
				details.source = source;
				msg += &quot;&lt;table&gt;&lt;tr class=&#x27;test-source&#x27;&gt;&lt;th&gt;Source: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + escapeInnerText( source ) + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&quot;;
			}
		}
		runLoggingCallbacks( &quot;log&quot;, QUnit, details );
		config.current.assertions.push({
			result: result,
			message: msg
		});
	},

	&#x2F;&#x2F; Checks that the first two arguments are equal, with an optional message. Prints out both actual and expected values.
	&#x2F;&#x2F; @example equal( format( &quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
	equal: function( actual, expected, message ) {
		QUnit.push( expected == actual, actual, expected, message );
	},

	notEqual: function( actual, expected, message ) {
		QUnit.push( expected != actual, actual, expected, message );
	},

	deepEqual: function( actual, expected, message ) {
		QUnit.push( QUnit.equiv(actual, expected), actual, expected, message );
	},

	notDeepEqual: function( actual, expected, message ) {
		QUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );
	},

	strictEqual: function( actual, expected, message ) {
		QUnit.push( expected === actual, actual, expected, message );
	},

	notStrictEqual: function( actual, expected, message ) {
		QUnit.push( expected !== actual, actual, expected, message );
	},

	raises: function( block, expected, message ) {
		var actual,
			ok = false;

		if ( typeof expected === &quot;string&quot; ) {
			message = expected;
			expected = null;
		}

		try {
			block.call( config.current.testEnvironment );
		} catch (e) {
			actual = e;
		}

		if ( actual ) {
			&#x2F;&#x2F; we don&#x27;t want to validate thrown error
			if ( !expected ) {
				ok = true;
			&#x2F;&#x2F; expected is a regexp
			} else if ( QUnit.objectType( expected ) === &quot;regexp&quot; ) {
				ok = expected.test( actual );
			&#x2F;&#x2F; expected is a constructor
			} else if ( actual instanceof expected ) {
				ok = true;
			&#x2F;&#x2F; expected is a validation function which returns true is validation passed
			} else if ( expected.call( {}, actual ) === true ) {
				ok = true;
			}
		}

		QUnit.ok( ok, message );
	},

	start: function( count ) {
		config.semaphore -= count || 1;
		&#x2F;&#x2F; don&#x27;t start until equal number of stop-calls
		if ( config.semaphore &gt; 0 ) {
			return;
		}
		&#x2F;&#x2F; ignore if start is called more often then stop
		if ( config.semaphore &lt; 0 ) {
			config.semaphore = 0;
		}
		&#x2F;&#x2F; A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.semaphore &gt; 0 ) {
					return;
				}
				if ( config.timeout ) {
					clearTimeout( config.timeout );
				}

				config.blocking = false;
				process( true );
			}, 13);
		} else {
			config.blocking = false;
			process( true );
		}
	},

	stop: function( count ) {
		config.semaphore += count || 1;
		config.blocking = true;

		if ( config.testTimeout &amp;&amp; defined.setTimeout ) {
			clearTimeout( config.timeout );
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, &quot;Test timed out&quot; );
				config.semaphore = 1;
				QUnit.start();
			}, config.testTimeout );
		}
	}
};

&#x2F;&#x2F; We want access to the constructor&#x27;s prototype
(function() {
	function F() {}
	F.prototype = QUnit;
	QUnit = new F();
	&#x2F;&#x2F; Make F QUnit&#x27;s constructor so that we can add to the prototype later
	QUnit.constructor = F;
}());

&#x2F;&#x2F; deprecated; still export them to window to provide clear error messages
&#x2F;&#x2F; next step: remove entirely
QUnit.equals = function() {
	QUnit.push( false, false, false, &quot;QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead&quot; );
};
QUnit.same = function() {
	QUnit.push( false, false, false, &quot;QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead&quot; );
};

&#x2F;&#x2F; Maintain internal state
&#x2F;&#x2F; &#x60;config&#x60; initialized at top of scope
config = {
	&#x2F;&#x2F; The queue of tests to run
	queue: [],

	&#x2F;&#x2F; block until document ready
	blocking: true,

	&#x2F;&#x2F; when enabled, show only failing tests
	&#x2F;&#x2F; gets persisted through sessionStorage and can be changed in UI via checkbox
	hidepassed: false,

	&#x2F;&#x2F; by default, run previously failed tests first
	&#x2F;&#x2F; very useful in combination with &quot;Hide passed tests&quot; checked
	reorder: true,

	&#x2F;&#x2F; by default, modify document.title when suite is done
	altertitle: true,

	urlConfig: [ &quot;noglobals&quot;, &quot;notrycatch&quot; ],

	&#x2F;&#x2F; logging callback queues
	begin: [],
	done: [],
	log: [],
	testStart: [],
	testDone: [],
	moduleStart: [],
	moduleDone: []
};

&#x2F;&#x2F; Load paramaters
(function() {
	var i,
		location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
		params = location.search.slice( 1 ).split( &quot;&amp;&quot; ),
		length = params.length,
		urlParams = {},
		current;

	if ( params[ 0 ] ) {
		for ( i = 0; i &lt; length; i++ ) {
			current = params[ i ].split( &quot;=&quot; );
			current[ 0 ] = decodeURIComponent( current[ 0 ] );
			&#x2F;&#x2F; allow just a key to turn on a flag, e.g., test.html?noglobals
			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
			urlParams[ current[ 0 ] ] = current[ 1 ];
		}
	}

	QUnit.urlParams = urlParams;
	config.filter = urlParams.filter;

	&#x2F;&#x2F; Figure out if we&#x27;re running the tests from a server or not
	QUnit.isLocal = location.protocol === &quot;file:&quot;;
}());

&#x2F;&#x2F; Expose the API as global variables, unless an &#x27;exports&#x27; object exists,
&#x2F;&#x2F; in that case we assume we&#x27;re in CommonJS - export everything at the end
if ( typeof exports === &quot;undefined&quot; ) {
	extend( window, QUnit );
	window.QUnit = QUnit;
}

&#x2F;&#x2F; define these after exposing globals to keep them in these QUnit namespace only
extend( QUnit, {
	config: config,

	&#x2F;&#x2F; Initialize the configuration options
	init: function() {
		extend( config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date(),
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filter: &quot;&quot;,
			queue: [],
			semaphore: 0
		});

		var tests, banner, result,
			qunit = id( &quot;qunit&quot; );

		if ( qunit ) {
			qunit.innerHTML =
				&quot;&lt;h1 id=&#x27;qunit-header&#x27;&gt;&quot; + escapeInnerText( document.title ) + &quot;&lt;&#x2F;h1&gt;&quot; +
				&quot;&lt;h2 id=&#x27;qunit-banner&#x27;&gt;&lt;&#x2F;h2&gt;&quot; +
				&quot;&lt;div id=&#x27;qunit-testrunner-toolbar&#x27;&gt;&lt;&#x2F;div&gt;&quot; +
				&quot;&lt;h2 id=&#x27;qunit-userAgent&#x27;&gt;&lt;&#x2F;h2&gt;&quot; +
				&quot;&lt;ol id=&#x27;qunit-tests&#x27;&gt;&lt;&#x2F;ol&gt;&quot;;
		}

		tests = id( &quot;qunit-tests&quot; );
		banner = id( &quot;qunit-banner&quot; );
		result = id( &quot;qunit-testresult&quot; );

		if ( tests ) {
			tests.innerHTML = &quot;&quot;;
		}

		if ( banner ) {
			banner.className = &quot;&quot;;
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}

		if ( tests ) {
			result = document.createElement( &quot;p&quot; );
			result.id = &quot;qunit-testresult&quot;;
			result.className = &quot;result&quot;;
			tests.parentNode.insertBefore( result, tests );
			result.innerHTML = &quot;Running...&lt;br&#x2F;&gt;&amp;nbsp;&quot;;
		}
	},

	&#x2F;&#x2F; Resets the test setup. Useful for tests that modify the DOM.
	&#x2F;&#x2F; If jQuery is available, uses jQuery&#x27;s html(), otherwise just innerHTML.
	reset: function() {
		var fixture;

		if ( window.jQuery ) {
			jQuery( &quot;#qunit-fixture&quot; ).html( config.fixture );
		} else {
			fixture = id( &quot;qunit-fixture&quot; );
			if ( fixture ) {
				fixture.innerHTML = config.fixture;
			}
		}
	},

	&#x2F;&#x2F; Trigger an event on an element.
	&#x2F;&#x2F; @example triggerEvent( document.body, &quot;click&quot; );
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent( &quot;MouseEvents&quot; );
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);

			elem.dispatchEvent( event );
		} else if ( elem.fireEvent ) {
			elem.fireEvent( &quot;on&quot; + type );
		}
	},

	&#x2F;&#x2F; Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},

	objectType: function( obj ) {
		if ( typeof obj === &quot;undefined&quot; ) {
				return &quot;undefined&quot;;
		&#x2F;&#x2F; consider: typeof null === object
		}
		if ( obj === null ) {
				return &quot;null&quot;;
		}

		var type = toString.call( obj ).match(&#x2F;^\[object\s(.*)\]$&#x2F;)[1] || &quot;&quot;;

		switch ( type ) {
			case &quot;Number&quot;:
				if ( isNaN(obj) ) {
					return &quot;nan&quot;;
				}
				return &quot;number&quot;;
			case &quot;String&quot;:
			case &quot;Boolean&quot;:
			case &quot;Array&quot;:
			case &quot;Date&quot;:
			case &quot;RegExp&quot;:
			case &quot;Function&quot;:
				return type.toLowerCase();
		}
		if ( typeof obj === &quot;object&quot; ) {
			return &quot;object&quot;;
		}
		return undefined;
	},

	push: function( result, actual, expected, message ) {
		if ( !config.current ) {
			throw new Error( &quot;assertion outside test context, was &quot; + sourceFromStacktrace() );
		}

		var output, source,
			details = {
				result: result,
				message: message,
				actual: actual,
				expected: expected
			};

		message = escapeInnerText( message ) || ( result ? &quot;okay&quot; : &quot;failed&quot; );
		message = &quot;&lt;span class=&#x27;test-message&#x27;&gt;&quot; + message + &quot;&lt;&#x2F;span&gt;&quot;;
		output = message;

		if ( !result ) {
			expected = escapeInnerText( QUnit.jsDump.parse(expected) );
			actual = escapeInnerText( QUnit.jsDump.parse(actual) );
			output += &quot;&lt;table&gt;&lt;tr class=&#x27;test-expected&#x27;&gt;&lt;th&gt;Expected: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + expected + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;

			if ( actual != expected ) {
				output += &quot;&lt;tr class=&#x27;test-actual&#x27;&gt;&lt;th&gt;Result: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + actual + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;
				output += &quot;&lt;tr class=&#x27;test-diff&#x27;&gt;&lt;th&gt;Diff: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + QUnit.diff( expected, actual ) + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;
			}

			source = sourceFromStacktrace();

			if ( source ) {
				details.source = source;
				output += &quot;&lt;tr class=&#x27;test-source&#x27;&gt;&lt;th&gt;Source: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + escapeInnerText( source ) + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;
			}

			output += &quot;&lt;&#x2F;table&gt;&quot;;
		}

		runLoggingCallbacks( &quot;log&quot;, QUnit, details );

		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},

	pushFailure: function( message, source ) {
		var output,
			details = {
				result: false,
				message: message
			};

		message = escapeInnerText(message ) || &quot;error&quot;;
		message = &quot;&lt;span class=&#x27;test-message&#x27;&gt;&quot; + message + &quot;&lt;&#x2F;span&gt;&quot;;
		output = message;

		if ( source ) {
			details.source = source;
			output += &quot;&lt;table&gt;&lt;tr class=&#x27;test-source&#x27;&gt;&lt;th&gt;Source: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&quot; + escapeInnerText( source ) + &quot;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&quot;;
		}

		runLoggingCallbacks( &quot;log&quot;, QUnit, details );

		config.current.assertions.push({
			result: false,
			message: output
		});
	},

	url: function( params ) {
		params = extend( extend( {}, QUnit.urlParams ), params );
		var key,
			querystring = &quot;?&quot;;

		for ( key in params ) {
			if ( !hasOwn.call( params, key ) ) {
				continue;
			}
			querystring += encodeURIComponent( key ) + &quot;=&quot; +
				encodeURIComponent( params[ key ] ) + &quot;&amp;&quot;;
		}
		return window.location.pathname + querystring.slice( 0, -1 );
	},

	extend: extend,
	id: id,
	addEvent: addEvent
});

&#x2F;&#x2F; QUnit.constructor is set to the empty F() above so that we can add to it&#x27;s prototype later
&#x2F;&#x2F; Doing this allows us to tell if the following methods have been overwritten on the actual
&#x2F;&#x2F; QUnit object, which is a deprecated way of using the callbacks.
extend( QUnit.constructor.prototype, {
	&#x2F;&#x2F; Logging callbacks; all receive a single argument with the listed properties
	&#x2F;&#x2F; run test&#x2F;logs.html for any related changes
	begin: registerLoggingCallback( &quot;begin&quot; ),
	&#x2F;&#x2F; done: { failed, passed, total, runtime }
	done: registerLoggingCallback( &quot;done&quot; ),
	&#x2F;&#x2F; log: { result, actual, expected, message }
	log: registerLoggingCallback( &quot;log&quot; ),
	&#x2F;&#x2F; testStart: { name }
	testStart: registerLoggingCallback( &quot;testStart&quot; ),
	&#x2F;&#x2F; testDone: { name, failed, passed, total }
	testDone: registerLoggingCallback( &quot;testDone&quot; ),
	&#x2F;&#x2F; moduleStart: { name }
	moduleStart: registerLoggingCallback( &quot;moduleStart&quot; ),
	&#x2F;&#x2F; moduleDone: { name, failed, passed, total }
	moduleDone: registerLoggingCallback( &quot;moduleDone&quot; )
});

if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
	config.autorun = true;
}

QUnit.load = function() {
	runLoggingCallbacks( &quot;begin&quot;, QUnit, {} );

	&#x2F;&#x2F; Initialize the config, saving the execution queue
	var banner, filter, i, label, len, main, ol, toolbar, userAgent, val,
		urlConfigHtml = &quot;&quot;,
		oldconfig = extend( {}, config );

	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	len = config.urlConfig.length;

	for ( i = 0; i &lt; len; i++ ) {
		val = config.urlConfig[i];
		config[val] = QUnit.urlParams[val];
		urlConfigHtml += &quot;&lt;label&gt;&lt;input name=&#x27;&quot; + val + &quot;&#x27; type=&#x27;checkbox&#x27;&quot; + ( config[val] ? &quot; checked=&#x27;checked&#x27;&quot; : &quot;&quot; ) + &quot;&gt;&quot; + val + &quot;&lt;&#x2F;label&gt;&quot;;
	}

	&#x2F;&#x2F; &#x60;userAgent&#x60; initialized at top of scope
	userAgent = id( &quot;qunit-userAgent&quot; );
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}

	&#x2F;&#x2F; &#x60;banner&#x60; initialized at top of scope
	banner = id( &quot;qunit-header&quot; );
	if ( banner ) {
		banner.innerHTML = &quot;&lt;a href=&#x27;&quot; + QUnit.url({ filter: undefined }) + &quot;&#x27;&gt;&quot; + banner.innerHTML + &quot;&lt;&#x2F;a&gt; &quot; + urlConfigHtml;
		addEvent( banner, &quot;change&quot;, function( event ) {
			var params = {};
			params[ event.target.name ] = event.target.checked ? true : undefined;
			window.location = QUnit.url( params );
		});
	}

	&#x2F;&#x2F; &#x60;toolbar&#x60; initialized at top of scope
	toolbar = id( &quot;qunit-testrunner-toolbar&quot; );
	if ( toolbar ) {
		&#x2F;&#x2F; &#x60;filter&#x60; initialized at top of scope
		filter = document.createElement( &quot;input&quot; );
		filter.type = &quot;checkbox&quot;;
		filter.id = &quot;qunit-filter-pass&quot;;

		addEvent( filter, &quot;click&quot;, function() {
			var tmp,
				ol = document.getElementById( &quot;qunit-tests&quot; );

			if ( filter.checked ) {
				ol.className = ol.className + &quot; hidepass&quot;;
			} else {
				tmp = &quot; &quot; + ol.className.replace( &#x2F;[\n\t\r]&#x2F;g, &quot; &quot; ) + &quot; &quot;;
				ol.className = tmp.replace( &#x2F; hidepass &#x2F;, &quot; &quot; );
			}
			if ( defined.sessionStorage ) {
				if (filter.checked) {
					sessionStorage.setItem( &quot;qunit-filter-passed-tests&quot;, &quot;true&quot; );
				} else {
					sessionStorage.removeItem( &quot;qunit-filter-passed-tests&quot; );
				}
			}
		});

		if ( config.hidepassed || defined.sessionStorage &amp;&amp; sessionStorage.getItem( &quot;qunit-filter-passed-tests&quot; ) ) {
			filter.checked = true;
			&#x2F;&#x2F; &#x60;ol&#x60; initialized at top of scope
			ol = document.getElementById( &quot;qunit-tests&quot; );
			ol.className = ol.className + &quot; hidepass&quot;;
		}
		toolbar.appendChild( filter );

		&#x2F;&#x2F; &#x60;label&#x60; initialized at top of scope
		label = document.createElement( &quot;label&quot; );
		label.setAttribute( &quot;for&quot;, &quot;qunit-filter-pass&quot; );
		label.innerHTML = &quot;Hide passed tests&quot;;
		toolbar.appendChild( label );
	}

	&#x2F;&#x2F; &#x60;main&#x60; initialized at top of scope
	main = id( &quot;qunit-fixture&quot; );
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if ( config.autostart ) {
		QUnit.start();
	}
};

addEvent( window, &quot;load&quot;, QUnit.load );

&#x2F;&#x2F; addEvent(window, &quot;error&quot; ) gives us a useless event object
window.onerror = function( message, file, line ) {
	if ( QUnit.config.current ) {
		QUnit.pushFailure( message, file + &quot;:&quot; + line );
	} else {
		QUnit.test( &quot;global failure&quot;, function() {
			QUnit.pushFailure( message, file + &quot;:&quot; + line );
		});
	}
};

function done() {
	config.autorun = true;

	&#x2F;&#x2F; Log the last module results
	if ( config.currentModule ) {
		runLoggingCallbacks( &quot;moduleDone&quot;, QUnit, {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		});
	}

	var i, key,
		banner = id( &quot;qunit-banner&quot; ),
		tests = id( &quot;qunit-tests&quot; ),
		runtime = +new Date() - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			&quot;Tests completed in &quot;,
			runtime,
			&quot; milliseconds.&lt;br&#x2F;&gt;&quot;,
			&quot;&lt;span class=&#x27;passed&#x27;&gt;&quot;,
			passed,
			&quot;&lt;&#x2F;span&gt; tests of &lt;span class=&#x27;total&#x27;&gt;&quot;,
			config.stats.all,
			&quot;&lt;&#x2F;span&gt; passed, &lt;span class=&#x27;failed&#x27;&gt;&quot;,
			config.stats.bad,
			&quot;&lt;&#x2F;span&gt; failed.&quot;
		].join( &quot;&quot; );

	if ( banner ) {
		banner.className = ( config.stats.bad ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot; );
	}

	if ( tests ) {
		id( &quot;qunit-testresult&quot; ).innerHTML = html;
	}

	if ( config.altertitle &amp;&amp; typeof document !== &quot;undefined&quot; &amp;&amp; document.title ) {
		&#x2F;&#x2F; show â for good, â for bad suite result in title
		&#x2F;&#x2F; use escape sequences in case file gets loaded with non-utf-8-charset
		document.title = [
			( config.stats.bad ? &quot;\u2716&quot; : &quot;\u2714&quot; ),
			document.title.replace( &#x2F;^[\u2714\u2716] &#x2F;i, &quot;&quot; )
		].join( &quot; &quot; );
	}

	&#x2F;&#x2F; clear own sessionStorage items if all tests passed
	if ( config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; config.stats.bad === 0 ) {
		&#x2F;&#x2F; &#x60;key&#x60; &amp; &#x60;i&#x60; initialized at top of scope
		for ( i = 0; i &lt; sessionStorage.length; i++ ) {
			key = sessionStorage.key( i++ );
			if ( key.indexOf( &quot;qunit-test-&quot; ) === 0 ) {
				sessionStorage.removeItem( key );
			}
		}
	}

	runLoggingCallbacks( &quot;done&quot;, QUnit, {
		failed: config.stats.bad,
		passed: passed,
		total: config.stats.all,
		runtime: runtime
	});
}

function validTest( name ) {
	var not,
		filter = config.filter,
		run = false;

	if ( !filter ) {
		return true;
	}

	not = filter.charAt( 0 ) === &quot;!&quot;;

	if ( not ) {
		filter = filter.slice( 1 );
	}

	if ( name.indexOf( filter ) !== -1 ) {
		return !not;
	}

	if ( not ) {
		run = true;
	}

	return run;
}

&#x2F;&#x2F; so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)
&#x2F;&#x2F; Later Safari and IE10 are supposed to support error.stack as well
&#x2F;&#x2F; See also https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Error&#x2F;Stack
function extractStacktrace( e, offset ) {
	offset = offset || 3;

	var stack;

	if ( e.stacktrace ) {
		&#x2F;&#x2F; Opera
		return e.stacktrace.split( &quot;\n&quot; )[ offset + 3 ];
	} else if ( e.stack ) {
		&#x2F;&#x2F; Firefox, Chrome
		stack = e.stack.split( &quot;\n&quot; );
		if (&#x2F;^error$&#x2F;i.test( stack[0] ) ) {
			stack.shift();
		}
		return stack[ offset ];
	} else if ( e.sourceURL ) {
		&#x2F;&#x2F; Safari, PhantomJS
		&#x2F;&#x2F; hopefully one day Safari provides actual stacktraces
		&#x2F;&#x2F; exclude useless self-reference for generated Error objects
		if ( &#x2F;qunit.js$&#x2F;.test( e.sourceURL ) ) {
			return;
		}
		&#x2F;&#x2F; for actual exceptions, this is useful
		return e.sourceURL + &quot;:&quot; + e.line;
	}
}
function sourceFromStacktrace( offset ) {
	try {
		throw new Error();
	} catch ( e ) {
		return extractStacktrace( e, offset );
	}
}

function escapeInnerText( s ) {
	if ( !s ) {
		return &quot;&quot;;
	}
	s = s + &quot;&quot;;
	return s.replace( &#x2F;[\&amp;&lt;&gt;]&#x2F;g, function( s ) {
		switch( s ) {
			case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;;
			case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;;
			case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;;
			default: return s;
		}
	});
}

function synchronize( callback, last ) {
	config.queue.push( callback );

	if ( config.autorun &amp;&amp; !config.blocking ) {
		process( last );
	}
}

function process( last ) {
	function next() {
		process( last );
	}
	var start = new Date().getTime();
	config.depth = config.depth ? config.depth + 1 : 1;

	while ( config.queue.length &amp;&amp; !config.blocking ) {
		if ( !defined.setTimeout || config.updateRate &lt;= 0 || ( ( new Date().getTime() - start ) &lt; config.updateRate ) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( next, 13 );
			break;
		}
	}
	config.depth--;
	if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {
		done();
	}
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			&#x2F;&#x2F; in Opera sometimes DOM element ids show up here, ignore them
			if ( !hasOwn.call( window, key ) || &#x2F;^qunit-test-output&#x2F;.test( key ) ) {
				continue;
			}
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var newGlobals,
		deletedGlobals,
		old = config.pollution;

	saveGlobal();

	newGlobals = diff( config.pollution, old );
	if ( newGlobals.length &gt; 0 ) {
		QUnit.pushFailure( &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
	}

	deletedGlobals = diff( old, config.pollution );
	if ( deletedGlobals.length &gt; 0 ) {
		QUnit.pushFailure( &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
	}
}

&#x2F;&#x2F; returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var i, j,
		result = a.slice();

	for ( i = 0; i &lt; result.length; i++ ) {
		for ( j = 0; j &lt; b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice( i, 1 );
				i--;
				break;
			}
		}
	}
	return result;
}

function extend( a, b ) {
	for ( var prop in b ) {
		if ( b[ prop ] === undefined ) {
			delete a[ prop ];

		&#x2F;&#x2F; Avoid &quot;Member not found&quot; error in IE8 caused by setting window.constructor
		} else if ( prop !== &quot;constructor&quot; || a !== window ) {
			a[ prop ] = b[ prop ];
		}
	}

	return a;
}

function addEvent( elem, type, fn ) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( &quot;on&quot; + type, fn );
	} else {
		fn();
	}
}

function id( name ) {
	return !!( typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById ) &amp;&amp;
		document.getElementById( name );
}

function registerLoggingCallback( key ) {
	return function( callback ) {
		config[key].push( callback );
	};
}

&#x2F;&#x2F; Supports deprecated method of completely overwriting logging callbacks
function runLoggingCallbacks( key, scope, args ) {
	&#x2F;&#x2F;debugger;
	var i, callbacks;
	if ( QUnit.hasOwnProperty( key ) ) {
		QUnit[ key ].call(scope, args );
	} else {
		callbacks = config[ key ];
		for ( i = 0; i &lt; callbacks.length; i++ ) {
			callbacks[ i ].call( scope, args );
		}
	}
}

&#x2F;&#x2F; Test for equality any JavaScript type.
&#x2F;&#x2F; Author: Philippe RathÃ© &lt;prathe@gmail.com&gt;
QUnit.equiv = (function() {

	&#x2F;&#x2F; Call the o related callback with the given arguments.
	function bindCallbacks( o, callbacks, args ) {
		var prop = QUnit.objectType( o );
		if ( prop ) {
			if ( QUnit.objectType( callbacks[ prop ] ) === &quot;function&quot; ) {
				return callbacks[ prop ].apply( callbacks, args );
			} else {
				return callbacks[ prop ]; &#x2F;&#x2F; or undefined
			}
		}
	}

	&#x2F;&#x2F; the real equiv function
	var innerEquiv,
		&#x2F;&#x2F; stack to decide between skip&#x2F;abort functions
		callers = [],
		&#x2F;&#x2F; stack to avoiding loops from circular referencing
		parents = [],

		getProto = Object.getPrototypeOf || function ( obj ) {
			return obj.__proto__;
		},
		callbacks = (function () {

			&#x2F;&#x2F; for string, boolean, number and null
			function useStrictEquality( b, a ) {
				if ( b instanceof a.constructor || a instanceof b.constructor ) {
					&#x2F;&#x2F; to catch short annotaion VS &#x27;new&#x27; annotation of a
					&#x2F;&#x2F; declaration
					&#x2F;&#x2F; e.g. var i = 1;
					&#x2F;&#x2F; var j = new Number(1);
					return a == b;
				} else {
					return a === b;
				}
			}

			return {
				&quot;string&quot;: useStrictEquality,
				&quot;boolean&quot;: useStrictEquality,
				&quot;number&quot;: useStrictEquality,
				&quot;null&quot;: useStrictEquality,
				&quot;undefined&quot;: useStrictEquality,

				&quot;nan&quot;: function( b ) {
					return isNaN( b );
				},

				&quot;date&quot;: function( b, a ) {
					return QUnit.objectType( b ) === &quot;date&quot; &amp;&amp; a.valueOf() === b.valueOf();
				},

				&quot;regexp&quot;: function( b, a ) {
					return QUnit.objectType( b ) === &quot;regexp&quot; &amp;&amp;
						&#x2F;&#x2F; the regex itself
						a.source === b.source &amp;&amp;
						&#x2F;&#x2F; and its modifers
						a.global === b.global &amp;&amp;
						&#x2F;&#x2F; (gmi) ...
						a.ignoreCase === b.ignoreCase &amp;&amp;
						a.multiline === b.multiline;
				},

				&#x2F;&#x2F; - skip when the property is a method of an instance (OOP)
				&#x2F;&#x2F; - abort otherwise,
				&#x2F;&#x2F; initial === would have catch identical references anyway
				&quot;function&quot;: function() {
					var caller = callers[callers.length - 1];
					return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
				},

				&quot;array&quot;: function( b, a ) {
					var i, j, len, loop;

					&#x2F;&#x2F; b could be an object literal here
					if ( QUnit.objectType( b ) !== &quot;array&quot; ) {
						return false;
					}

					len = a.length;
					if ( len !== b.length ) {
						&#x2F;&#x2F; safe and faster
						return false;
					}

					&#x2F;&#x2F; track reference to avoid circular references
					parents.push( a );
					for ( i = 0; i &lt; len; i++ ) {
						loop = false;
						for ( j = 0; j &lt; parents.length; j++ ) {
							if ( parents[j] === a[i] ) {
								loop = true;&#x2F;&#x2F; dont rewalk array
							}
						}
						if ( !loop &amp;&amp; !innerEquiv(a[i], b[i]) ) {
							parents.pop();
							return false;
						}
					}
					parents.pop();
					return true;
				},

				&quot;object&quot;: function( b, a ) {
					var i, j, loop,
						&#x2F;&#x2F; Default to true
						eq = true,
						aProperties = [],
						bProperties = [];

					&#x2F;&#x2F; comparing constructors is more strict than using
					&#x2F;&#x2F; instanceof
					if ( a.constructor !== b.constructor ) {
						&#x2F;&#x2F; Allow objects with no prototype to be equivalent to
						&#x2F;&#x2F; objects with Object as their constructor.
						if ( !(( getProto(a) === null &amp;&amp; getProto(b) === Object.prototype ) ||
							( getProto(b) === null &amp;&amp; getProto(a) === Object.prototype ) ) ) {
								return false;
						}
					}

					&#x2F;&#x2F; stack constructor before traversing properties
					callers.push( a.constructor );
					&#x2F;&#x2F; track reference to avoid circular references
					parents.push( a );

					for ( i in a ) { &#x2F;&#x2F; be strict: don&#x27;t ensures hasOwnProperty
									&#x2F;&#x2F; and go deep
						loop = false;
						for ( j = 0; j &lt; parents.length; j++ ) {
							if ( parents[j] === a[i] ) {
								&#x2F;&#x2F; don&#x27;t go down the same path twice
								loop = true;
							}
						}
						aProperties.push(i); &#x2F;&#x2F; collect a&#x27;s properties

						if (!loop &amp;&amp; !innerEquiv( a[i], b[i] ) ) {
							eq = false;
							break;
						}
					}

					callers.pop(); &#x2F;&#x2F; unstack, we are done
					parents.pop();

					for ( i in b ) {
						bProperties.push( i ); &#x2F;&#x2F; collect b&#x27;s properties
					}

					&#x2F;&#x2F; Ensures identical properties name
					return eq &amp;&amp; innerEquiv( aProperties.sort(), bProperties.sort() );
				}
			};
		}());

	innerEquiv = function() { &#x2F;&#x2F; can take multiple arguments
		var args = [].slice.apply( arguments );
		if ( args.length &lt; 2 ) {
			return true; &#x2F;&#x2F; end transition
		}

		return (function( a, b ) {
			if ( a === b ) {
				return true; &#x2F;&#x2F; catch the most you can
			} else if ( a === null || b === null || typeof a === &quot;undefined&quot; ||
					typeof b === &quot;undefined&quot; ||
					QUnit.objectType(a) !== QUnit.objectType(b) ) {
				return false; &#x2F;&#x2F; don&#x27;t lose time with error prone cases
			} else {
				return bindCallbacks(a, callbacks, [ b, a ]);
			}

			&#x2F;&#x2F; apply transition with (1..n) arguments
		}( args[0], args[1] ) &amp;&amp; arguments.callee.apply( this, args.splice(1, args.length - 1 )) );
	};

	return innerEquiv;
}());

&#x2F;**
 * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |
 * http:&#x2F;&#x2F;flesler.blogspot.com Licensed under BSD
 * (http:&#x2F;&#x2F;www.opensource.org&#x2F;licenses&#x2F;bsd-license.php) Date: 5&#x2F;15&#x2F;2008
 *
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http:&#x2F;&#x2F;flesler.blogspot.com&#x2F;2008&#x2F;05&#x2F;jsdump-pretty-dump-of-any-javascript.html}
 *&#x2F;
QUnit.jsDump = (function() {
	function quote( str ) {
		return &#x27;&quot;&#x27; + str.toString().replace( &#x2F;&quot;&#x2F;g, &#x27;\\&quot;&#x27; ) + &#x27;&quot;&#x27;;
	}
	function literal( o ) {
		return o + &quot;&quot;;
	}
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join ) {
			arr = arr.join( &quot;,&quot; + s + inner );
		}
		if ( !arr ) {
			return pre + post;
		}
		return [ pre, inner + arr, base + post ].join(s);
	}
	function array( arr, stack ) {
		var i = arr.length, ret = new Array(i);
		this.up();
		while ( i-- ) {
			ret[i] = this.parse( arr[i] , undefined , stack);
		}
		this.down();
		return join( &quot;[&quot;, ret, &quot;]&quot; );
	}

	var reName = &#x2F;^function (\w+)&#x2F;,
		jsDump = {
			parse: function( obj, type, stack ) { &#x2F;&#x2F;type is used mostly internally, you can fix a (custom)type in advance
				stack = stack || [ ];
				var inStack, res,
					parser = this.parsers[ type || this.typeOf(obj) ];

				type = typeof parser;
				inStack = inArray( obj, stack );

				if ( inStack != -1 ) {
					return &quot;recursion(&quot; + (inStack - stack.length) + &quot;)&quot;;
				}
				&#x2F;&#x2F;else
				if ( type == &quot;function&quot; )  {
					stack.push( obj );
					res = parser.call( this, obj, stack );
					stack.pop();
					return res;
				}
				&#x2F;&#x2F; else
				return ( type == &quot;string&quot; ) ? parser : this.parsers.error;
			},
			typeOf: function( obj ) {
				var type;
				if ( obj === null ) {
					type = &quot;null&quot;;
				} else if ( typeof obj === &quot;undefined&quot; ) {
					type = &quot;undefined&quot;;
				} else if ( QUnit.is( &quot;RegExp&quot;, obj) ) {
					type = &quot;regexp&quot;;
				} else if ( QUnit.is( &quot;Date&quot;, obj) ) {
					type = &quot;date&quot;;
				} else if ( QUnit.is( &quot;Function&quot;, obj) ) {
					type = &quot;function&quot;;
				} else if ( typeof obj.setInterval !== undefined &amp;&amp; typeof obj.document !== &quot;undefined&quot; &amp;&amp; typeof obj.nodeType === &quot;undefined&quot; ) {
					type = &quot;window&quot;;
				} else if ( obj.nodeType === 9 ) {
					type = &quot;document&quot;;
				} else if ( obj.nodeType ) {
					type = &quot;node&quot;;
				} else if (
					&#x2F;&#x2F; native arrays
					toString.call( obj ) === &quot;[object Array]&quot; ||
					&#x2F;&#x2F; NodeList objects
					( typeof obj.length === &quot;number&quot; &amp;&amp; typeof obj.item !== &quot;undefined&quot; &amp;&amp; ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null &amp;&amp; typeof obj[0] === &quot;undefined&quot; ) ) )
				) {
					type = &quot;array&quot;;
				} else {
					type = typeof obj;
				}
				return type;
			},
			separator: function() {
				return this.multiline ?	this.HTML ? &quot;&lt;br &#x2F;&gt;&quot; : &quot;\n&quot; : this.HTML ? &quot;&amp;nbsp;&quot; : &quot; &quot;;
			},
			indent: function( extra ) {&#x2F;&#x2F; extra can be a number, shortcut for increasing-calling-decreasing
				if ( !this.multiline ) {
					return &quot;&quot;;
				}
				var chr = this.indentChar;
				if ( this.HTML ) {
					chr = chr.replace( &#x2F;\t&#x2F;g, &quot;   &quot; ).replace( &#x2F; &#x2F;g, &quot;&amp;nbsp;&quot; );
				}
				return new Array( this._depth_ + (extra||0) ).join(chr);
			},
			up: function( a ) {
				this._depth_ += a || 1;
			},
			down: function( a ) {
				this._depth_ -= a || 1;
			},
			setParser: function( name, parser ) {
				this.parsers[name] = parser;
			},
			&#x2F;&#x2F; The next 3 are exposed so you can use them
			quote: quote,
			literal: literal,
			join: join,
			&#x2F;&#x2F;
			_depth_: 1,
			&#x2F;&#x2F; This is the list of parsers, to modify them, use jsDump.setParser
			parsers: {
				window: &quot;[Window]&quot;,
				document: &quot;[Document]&quot;,
				error: &quot;[ERROR]&quot;, &#x2F;&#x2F;when no parser is found, shouldn&quot;t happen
				unknown: &quot;[Unknown]&quot;,
				&quot;null&quot;: &quot;null&quot;,
				&quot;undefined&quot;: &quot;undefined&quot;,
				&quot;function&quot;: function( fn ) {
					var ret = &quot;function&quot;,
						name = &quot;name&quot; in fn ? fn.name : (reName.exec(fn) || [])[1];&#x2F;&#x2F;functions never have name in IE

					if ( name ) {
						ret += &quot; &quot; + name;
					}
					ret += &quot;( &quot;;

					ret = [ ret, QUnit.jsDump.parse( fn, &quot;functionArgs&quot; ), &quot;){&quot; ].join( &quot;&quot; );
					return join( ret, QUnit.jsDump.parse(fn,&quot;functionCode&quot; ), &quot;}&quot; );
				},
				array: array,
				nodelist: array,
				&quot;arguments&quot;: array,
				object: function( map, stack ) {
					var ret = [ ], keys, key, val, i;
					QUnit.jsDump.up();
					if ( Object.keys ) {
						keys = Object.keys( map );
					} else {
						keys = [];
						for ( key in map ) {
							keys.push( key );
						}
					}
					keys.sort();
					for ( i = 0; i &lt; keys.length; i++ ) {
						key = keys[ i ];
						val = map[ key ];
						ret.push( QUnit.jsDump.parse( key, &quot;key&quot; ) + &quot;: &quot; + QUnit.jsDump.parse( val, undefined, stack ) );
					}
					QUnit.jsDump.down();
					return join( &quot;{&quot;, ret, &quot;}&quot; );
				},
				node: function( node ) {
					var a, val,
						open = QUnit.jsDump.HTML ? &quot;&amp;lt;&quot; : &quot;&lt;&quot;,
						close = QUnit.jsDump.HTML ? &quot;&amp;gt;&quot; : &quot;&gt;&quot;,
						tag = node.nodeName.toLowerCase(),
						ret = open + tag;

					for ( a in QUnit.jsDump.DOMAttrs ) {
						val = node[ QUnit.jsDump.DOMAttrs[a] ];
						if ( val ) {
							ret += &quot; &quot; + a + &quot;=&quot; + QUnit.jsDump.parse( val, &quot;attribute&quot; );
						}
					}
					return ret + close + open + &quot;&#x2F;&quot; + tag + close;
				},
				functionArgs: function( fn ) {&#x2F;&#x2F;function calls it internally, it&#x27;s the arguments part of the function
					var args,
						l = fn.length;

					if ( !l ) {
						return &quot;&quot;;
					}

					args = new Array(l);
					while ( l-- ) {
						args[l] = String.fromCharCode(97+l);&#x2F;&#x2F;97 is &#x27;a&#x27;
					}
					return &quot; &quot; + args.join( &quot;, &quot; ) + &quot; &quot;;
				},
				key: quote, &#x2F;&#x2F;object calls it internally, the key part of an item in a map
				functionCode: &quot;[code]&quot;, &#x2F;&#x2F;function calls it internally, it&#x27;s the content of the function
				attribute: quote, &#x2F;&#x2F;node calls it internally, it&#x27;s an html attribute value
				string: quote,
				date: quote,
				regexp: literal, &#x2F;&#x2F;regex
				number: literal,
				&quot;boolean&quot;: literal
			},
			DOMAttrs: {
				&#x2F;&#x2F;attributes to dump from nodes, name=&gt;realName
				id: &quot;id&quot;,
				name: &quot;name&quot;,
				&quot;class&quot;: &quot;className&quot;
			},
			HTML: false,&#x2F;&#x2F;if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
			indentChar: &quot;  &quot;,&#x2F;&#x2F;indentation unit
			multiline: true &#x2F;&#x2F;if true, items in a collection, are separated by a \n, else just a space.
		};

	return jsDump;
}());

&#x2F;&#x2F; from Sizzle.js
function getText( elems ) {
	var i, elem,
		ret = &quot;&quot;;

	for ( i = 0; elems[i]; i++ ) {
		elem = elems[i];

		&#x2F;&#x2F; Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		&#x2F;&#x2F; Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
}

&#x2F;&#x2F; from jquery.js
function inArray( elem, array ) {
	if ( array.indexOf ) {
		return array.indexOf( elem );
	}

	for ( var i = 0, length = array.length; i &lt; length; i++ ) {
		if ( array[ i ] === elem ) {
			return i;
		}
	}

	return -1;
}

&#x2F;*
 * Javascript Diff Algorithm
 *  By John Resig (http:&#x2F;&#x2F;ejohn.org&#x2F;)
 *  Modified by Chu Alan &quot;sprite&quot;
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http:&#x2F;&#x2F;ejohn.org&#x2F;projects&#x2F;javascript-diff-algorithm&#x2F;
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff( &quot;the quick brown fox jumped over&quot;, &quot;the quick fox jumps over&quot; ) == &quot;the  quick &lt;del&gt;brown &lt;&#x2F;del&gt; fox &lt;del&gt;jumped &lt;&#x2F;del&gt;&lt;ins&gt;jumps &lt;&#x2F;ins&gt; over&quot;
 *&#x2F;
QUnit.diff = (function() {
	function diff( o, n ) {
		var i,
			ns = {},
			os = {};

		for ( i = 0; i &lt; n.length; i++ ) {
			if ( ns[ n[i] ] == null ) {
				ns[ n[i] ] = {
					rows: [],
					o: null
				};
			}
			ns[ n[i] ].rows.push( i );
		}

		for ( i = 0; i &lt; o.length; i++ ) {
			if ( os[ o[i] ] == null ) {
				os[ o[i] ] = {
					rows: [],
					n: null
				};
			}
			os[ o[i] ].rows.push( i );
		}

		for ( i in ns ) {
			if ( !hasOwn.call( ns, i ) ) {
				continue;
			}
			if ( ns[i].rows.length == 1 &amp;&amp; typeof os[i] != &quot;undefined&quot; &amp;&amp; os[i].rows.length == 1 ) {
				n[ ns[i].rows[0] ] = {
					text: n[ ns[i].rows[0] ],
					row: os[i].rows[0]
				};
				o[ os[i].rows[0] ] = {
					text: o[ os[i].rows[0] ],
					row: ns[i].rows[0]
				};
			}
		}

		for ( i = 0; i &lt; n.length - 1; i++ ) {
			if ( n[i].text != null &amp;&amp; n[ i + 1 ].text == null &amp;&amp; n[i].row + 1 &lt; o.length &amp;&amp; o[ n[i].row + 1 ].text == null &amp;&amp;
						n[ i + 1 ] == o[ n[i].row + 1 ] ) {

				n[ i + 1 ] = {
					text: n[ i + 1 ],
					row: n[i].row + 1
				};
				o[ n[i].row + 1 ] = {
					text: o[ n[i].row + 1 ],
					row: i + 1
				};
			}
		}

		for ( i = n.length - 1; i &gt; 0; i-- ) {
			if ( n[i].text != null &amp;&amp; n[ i - 1 ].text == null &amp;&amp; n[i].row &gt; 0 &amp;&amp; o[ n[i].row - 1 ].text == null &amp;&amp;
						n[ i - 1 ] == o[ n[i].row - 1 ]) {

				n[ i - 1 ] = {
					text: n[ i - 1 ],
					row: n[i].row - 1
				};
				o[ n[i].row - 1 ] = {
					text: o[ n[i].row - 1 ],
					row: i - 1
				};
			}
		}

		return {
			o: o,
			n: n
		};
	}

	return function( o, n ) {
		o = o.replace( &#x2F;\s+$&#x2F;, &quot;&quot; );
		n = n.replace( &#x2F;\s+$&#x2F;, &quot;&quot; );

		var i, pre,
			str = &quot;&quot;,
			out = diff( o === &quot;&quot; ? [] : o.split(&#x2F;\s+&#x2F;), n === &quot;&quot; ? [] : n.split(&#x2F;\s+&#x2F;) ),
			oSpace = o.match(&#x2F;\s+&#x2F;g),
			nSpace = n.match(&#x2F;\s+&#x2F;g);

		if ( oSpace == null ) {
			oSpace = [ &quot; &quot; ];
		}
		else {
			oSpace.push( &quot; &quot; );
		}

		if ( nSpace == null ) {
			nSpace = [ &quot; &quot; ];
		}
		else {
			nSpace.push( &quot; &quot; );
		}

		if ( out.n.length === 0 ) {
			for ( i = 0; i &lt; out.o.length; i++ ) {
				str += &quot;&lt;del&gt;&quot; + out.o[i] + oSpace[i] + &quot;&lt;&#x2F;del&gt;&quot;;
			}
		}
		else {
			if ( out.n[0].text == null ) {
				for ( n = 0; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++ ) {
					str += &quot;&lt;del&gt;&quot; + out.o[n] + oSpace[n] + &quot;&lt;&#x2F;del&gt;&quot;;
				}
			}

			for ( i = 0; i &lt; out.n.length; i++ ) {
				if (out.n[i].text == null) {
					str += &quot;&lt;ins&gt;&quot; + out.n[i] + nSpace[i] + &quot;&lt;&#x2F;ins&gt;&quot;;
				}
				else {
					&#x2F;&#x2F; &#x60;pre&#x60; initialized at top of scope
					pre = &quot;&quot;;

					for ( n = out.n[i].row + 1; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++ ) {
						pre += &quot;&lt;del&gt;&quot; + out.o[n] + oSpace[n] + &quot;&lt;&#x2F;del&gt;&quot;;
					}
					str += &quot; &quot; + out.n[i].text + nSpace[i] + pre;
				}
			}
		}

		return str;
	};
}());

&#x2F;&#x2F; for CommonJS enviroments, export everything
if ( typeof exports !== &quot;undefined&quot; ) {
	extend(exports, QUnit);
}

&#x2F;&#x2F; get at whatever the global object is, like window in browsers
}( (function() {return this;}.call()) ));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
